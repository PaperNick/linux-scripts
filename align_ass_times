#!/usr/bin/env python

import argparse
import re

from pathlib import Path
from textwrap import dedent
from typing import Optional


def find_column_index(format_line: str, search_column: str) -> Optional[int]:
    """
    Finds the index of a specified column within a Format subtitle line.

    Args:
        format_line: A string representing the format line of the subtitle file, typically in the format:
            "Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text"
        search_column: The name of the column to search for (case-insensitive)

    Returns:
        The index of the specified column in the format line, or None if the column is not found.

    Example:
        If format_line="Format: Layer, Start, End, Text" and search_column="End", the function returns 2.
    """
    search_column = search_column.lower()
    columns = map(lambda l: l.strip().lower(), format_line.removeprefix('Format:').split(','))
    return next((ind for ind, column_name in enumerate(columns) if column_name == search_column), None)


def parse_timestamp_ms(timestamp: str) -> int:
    """
    Parses a timestamp string in the format "HH:MM:SS.ms" into milliseconds.

    Args:
        timestamp: The timestamp string to parse.
        Example: "0:00:08.48"
    Returns:
        The timestamp in milliseconds as an integer.
    Raises:
        ValueError: If the timestamp string is not in the expected format.
    """
    hh, mm, ss, ms = map(int, re.split(r":|\.", timestamp))
    timestamp_ms = (((hh * 3600) + (mm * 60) + ss) * 1000) + ms
    return timestamp_ms


def align_overlapping_times(sub_file: str) -> str:
    """
    Fixes overlapping start and end times in an ASS subtitle file by aligning
    the end time of the dialogue with the start time of the next one.

    Args:
        sub_file: The content of the ASS subtitle file as a string.
    Returns:
        The modified subtitle file content as a string with overlapping times aligned.

    Example of overlapping time:
        ```
        Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
        Dialogue: 0,0:01:31.96,0:01:35.10,Default,,0,0,0,,Subtitle text 1
        Dialogue: 0,0:01:35.09,0:01:40.09,Default,,0,0,0,,Subtitle text 2
        ```
        In this example, the end time of the first subtitle (0:01:35.10) and the
        start time of the second subtitle (0:01:35.09) are very close, potentially
        causing issues during playback. This function will align the end time of
        the first subtitle to match the start time of the second subtitle.
    """
    file_lines = sub_file.splitlines()
    start_column_ind = None
    end_column_ind = None
    processed_lines = []
    for ind, current_line in enumerate(file_lines):
        current_line = current_line.strip()
        try:
            next_line = file_lines[ind + 1].strip()
        except IndexError:
            next_line = ""

        if current_line.startswith("Format:"):
            start_column_ind = find_column_index(current_line, "Start")
            end_column_ind = find_column_index(current_line, "End")
        elif current_line.startswith("Dialogue:") and next_line.startswith("Dialogue:"):
            current_line_parts = current_line.split(",")
            next_line_parts = next_line.split(",")

            current_end_time = current_line_parts[end_column_ind].strip()
            next_start_time = next_line_parts[start_column_ind].strip()

            if current_end_time != next_start_time:
                if parse_timestamp_ms(current_end_time) > parse_timestamp_ms(next_start_time):
                    # Invalid end time detected. Align the overlapping start and end times
                    current_line_parts[end_column_ind] = next_start_time
                    current_line = ",".join(current_line_parts)

        processed_lines.append(current_line)

    # Use POSIX line end for all platforms:
    # https://docs.python.org/3/library/os.html#os.linesep
    return "\n".join(processed_lines)


def main():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description=dedent(
            """
            Corrects overlapping start/end times in ASS subtitle files.

            This CLI tool is helpful when converting subtitles with
            higher time precision (e.g., SRT), where rounding errors
            can sometimes lead to overlaps.
            """
        )
    )
    parser.add_argument("subtitle_file", help="The path to the ASS subtitle file")
    args = parser.parse_args()

    sub_file = Path(args.subtitle_file)
    if not sub_file.exists():
        print(f"Error: File '{sub_file}' doesn't exist")
        exit(1)
    if sub_file.suffix.lower() != ".ass":
        print("Error: Only ASS subtitle files are supported")
        exit(1)

    sub_file_text = sub_file.read_text()
    aligned_sub_file_text = align_overlapping_times(sub_file_text)

    if sub_file_text.strip() == aligned_sub_file_text.strip():
        print("No overlapping start and end times found")
    else:
        new_sub_file = Path(f"{sub_file.with_suffix('')} (aligned){sub_file.suffix}")
        new_sub_file.write_text(aligned_sub_file_text)
        print(f"Overlapping times have been fixed! Saving to: '{new_sub_file}'")


if __name__ == "__main__":
    main()
